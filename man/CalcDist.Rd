% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_dens.R, R/calc_dist.R
\name{.calc_dens}
\alias{.calc_dens}
\alias{.calc_dist}
\alias{.calc_kl}
\alias{.calc_JS}
\title{Calculate density for each sample based on reduced dimension embedding}
\usage{
.calc_dens(
  df_list,
  dens = "GMM",
  k = 50,
  num_components = c(1:9),
  BPPARAM = BiocParallel::bpparam()
)

.calc_dist(
  mod_list,
  s1,
  s2,
  df_list,
  dist_mat,
  dens,
  r,
  k,
  ndim = 10,
  varapp = FALSE,
  epapp = FALSE,
  ep = NA
)

.calc_kl(
  mod_list,
  df_list,
  sample1,
  sample2,
  dens,
  r = 10000,
  k = 50,
  varapp = FALSE,
  epapp = FALSE,
  ep = NA
)

.calc_JS(
  mod_list,
  df_list,
  sample1,
  sample2,
  dens,
  ndim = 10,
  r = 10000,
  k = 50
)
}
\arguments{
\item{df_list}{A named list with each sample's reduced dimension embedding}

\item{dens}{The density estimation method (GMM or KNN)}

\item{k}{Number of k nearest neighbours for KNN density estimation, default k = 50.}

\item{num_components}{a vector of integers for the number of components to fit GMMS to, default is 1:9}

\item{BPPARAM}{BiocParallel parameters}

\item{mod_list}{A named list with each sample's estimated density}

\item{s1}{The name or index of the first sample in a pair (must be a key in mod_list)}

\item{s2}{The name or index of the second sample in a pair}

\item{dist_mat}{The distance metric to use (KL or JS)}

\item{r}{Number of Monte Carlo simulations to generate}

\item{ndim}{The number of dimension reduction to keep if using k-NN}

\item{varapp}{Boolean for using variation approximation of KL divergence; NOTE: Currently disabled'}

\item{epapp}{Boolean for applying an epsilon perturbation to MC calculated KL, default = FALSE}

\item{ep}{Epsilon perturbation size to add to MC KL divergence calculation, default = NA}

\item{sample1}{The name or index of the first sample in a pair (must be a key in mod_list)}

\item{sample2}{The name or index of the second sample in a pair}
}
\value{
mod_list: a list of length number of samples, contains the estimated density for each
sample

The estimated statistical divergence between two GloScope represenations

a numeric value of distance between sample1 and sample2's distribution.

a numeric value of distance between sample1 and sample2's distribution.
}
\description{
This function fits separate multivariate densities to each sample.
As input, the function expects a named list with names corresponding to sample IDs,
and elements holding a matrix or data.frame of dimensionality reduced cells from the samples.
Each matrix-type will have rows corresponding to each cell and columns corresponding to
the cells projection into a latent dimension. The k-nearest neighbour algorithm
does density and distance estimation in a single step, and for that `dens` specification
this function simply returns the input embedding matrices (see R/calc_dist.R).

This function calculates a statistical divergences between
two specified samples of an input list of sample GloScope representations. Different
subroutines are called depending on the divergence specified (symmetric KL or Jensen-Shannon)
and density estimation used for the GloScope representations (GMM or KNN).

This calculates the symmetric KL divergence between two
GloScope representations. This is implemented with Monte Carlo approximation
(with an optional epsilon perturbation term) if GMM is used for the density
estimate of each cell or a plug-in formula if KNN is used for the density.

This calculates the Jensen-Shannon distance between two
GloScope representations. This is implemented with Monte Carlo approximation
(with an optional epsilon perturbation term) if GMM is used for the density
estimate of each cell or a plug-in formula if KNN is used for the density.
}
\examples{
data(example_data)
sample_ids <- example_data$metadata$sample_id
pca_embeddings <- example_data$pca_embeddings
pca_embeddings_subset <- pca_embeddings[,1:10] # select the first 10 PCs
# the following `lapply` creates the necessary input data structure for this fn.
embeddings_list <- lapply(unique(sample_ids),function(x){pca_embeddings_subset[(sample_ids==x),]})
names(embeddings_list) <- unique(sample_ids)
mod_list <- .calc_dens(embeddings_list, dens = "GMM", BPPARAM = BiocParallel::SerialParam())

data(example_data)
sample_ids <- example_data$metadata$sample_id
pca_embeddings <- example_data$pca_embeddings
pca_embeddings_subset <- pca_embeddings[,1:10] # select the first 10 PCs
embeddings_list <- lapply(unique(sample_ids),function(x){pca_embeddings_subset[(sample_ids==x),]})
names(embeddings_list) <- unique(sample_ids)
density_list <- .calc_dens(embeddings_list, dens = "KNN")
sample_pairs <- utils::combn(unique(sample_ids), 2)
patient_pair_list <- lapply(seq_len(ncol(sample_pairs)), function(i) sample_pairs[,i])
w <- patient_pair_list[[1]]
.calc_dist(mod_list = density_list, df_list = embeddings_list, dens = "KNN", k = 50,
           s1 = w[1], s2 = w[2], dist_mat = "KL")
data(example_data)
sample_ids <- example_data$metadata$sample_id
pca_embeddings <- example_data$pca_embeddings
pca_embeddings_subset <- pca_embeddings[,1:10] # select the first 10 PCs
embeddings_list <- lapply(unique(sample_ids),function(x){pca_embeddings_subset[(sample_ids==x),]})
names(embeddings_list) <- unique(sample_ids)
density_list <- .calc_dens(embeddings_list, dens = "KNN")
sample_pairs <- utils::combn(unique(sample_ids), 2)
patient_pair_list <- lapply(seq_len(ncol(sample_pairs)), function(i) sample_pairs[,i])
w <- patient_pair_list[[1]]
.calc_kl(density_list, embeddings_list, w[1], w[2], dens = "KNN")
data(example_data)
sample_ids <- example_data$metadata$sample_id
pca_embeddings <- example_data$pca_embeddings
pca_embeddings_subset <- pca_embeddings[,1:10] # select the first 10 PCs
embeddings_list <- lapply(unique(sample_ids),function(x){pca_embeddings_subset[(sample_ids==x),]})
names(embeddings_list) <- unique(sample_ids)
density_list <- .calc_dens(embeddings_list, dens = "KNN")
sample_pairs <- utils::combn(unique(sample_ids), 2)
patient_pair_list <- lapply(seq_len(ncol(sample_pairs)), function(i) sample_pairs[,i])
w <- patient_pair_list[[1]]
.calc_JS(density_list, embeddings_list,w[1], w[2], dens = "KNN", ndim = 10)
}
