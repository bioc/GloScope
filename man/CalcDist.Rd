% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calc_dens.R, R/calc_dist.R
\name{.calc_dens}
\alias{.calc_dens}
\alias{.calc_dist}
\alias{.calc_kl}
\alias{.calc_JS}
\title{calculate density for each samples based on dimension reduction embedding}
\usage{
.calc_dens(
  df_list,
  dens = "GMM",
  k = 50,
  num_components = c(1:9),
  BPPARAM = BiocParallel::bpparam()
)

.calc_dist(
  mod_list,
  s1,
  s2,
  df_list,
  dist_mat,
  dens,
  r,
  k,
  ndim = 10,
  varapp = FALSE,
  epapp = FALSE,
  ep = NA
)

.calc_kl(mod_list, sample1, sample2, df_list, r, dens, k, epapp, ep)

.calc_JS(mod_list, sample1, sample2, df_list, r, dens, k, ep, ndim)
}
\arguments{
\item{df_list}{a list contain each samples' dimension reduction embedding}

\item{dens}{type of density to estimate for.}

\item{k}{number of k nearest negibhour for KNN density estimation, default k = 50.}

\item{num_components}{a vector of integers for the number of components to fit GMMS to, default is 1:9}

\item{BPPARAM}{BiocParallel parameters}

\item{mod_list}{a list contains each samples' estimated density}

\item{s1}{sample 1 name}

\item{s2}{sample 2 name}

\item{dist_mat}{which distance metric to use}

\item{r}{number of monte-carlo simulations to generate}

\item{ndim}{number of dimension reduction to keep}

\item{varapp}{logic variable for using variational approximation or not}

\item{epapp}{whether to apply the error term}

\item{ep}{error term added to the KL divergence calculation}

\item{sample1}{sample 1 index}

\item{sample2}{sample 2 index}
}
\value{
mod_list: a list of length number of samples, contains the estimated density for each
sample

a numeric value of estimated symmatrised KL divergence between
sample1 and sample2's distribution.

a numeric value of distance between sample1 and sample2's distribution.

a numeric value of distance between sample1 and sample2's distribution.
}
\description{
This function loads a vector of the sample names, with length of the
 number of samples whose density is to be estimated, a data frame x contains the info
 of cells, with row number equals the cell number, a data matrix or frame dim_redu
 contains dimension reduction embedding for each cell, which is used to calculate the
 density for each sample.

This function loads the metadata, which contains the sample id, disease group, dimension reduction embedding which has names
in the form "dim_i". Dimension reduction embedding is used to calculate the density for each sample, denoted by their sample id.

This function loads the metadata, which contains the sample id, disease group, dimension reduction embedding which has names
in the form "dim_i". Dimension reduction embedding is used to calculate the density for each sample, denoted by their sample id.

This function loads the metadata, which contains the sample id, disease group, dimension reduction embedding which has names
in the form "dim_i". Dimension reduction embedding is used to calculate the density for each sample, denoted by their sample id.
}
\examples{
data("example_data")
library(stringr)
sample_name <- as.character(unique(example_data[, "patient_id"]))
example_data[,"patient_id"] <- as.character(example_data[,"patient_id"])
df_list <- split(example_data, example_data[,"patient_id"])
df_list <- lapply(df_list, function(y) y[,str_detect(colnames(y), "PC")])
df_list <- lapply(df_list, function(y) as.matrix(y[,1:10]))
#working with large data set, use BiocParallel
mod_list <- .calc_dens(df_list, dens = "KNN", BPPARAM = BiocParallel::SerialParam())


data(example_data)
library(stringr)
sample_name <- as.character(unique(example_data[, "patient_id"]))
example_data[,"patient_id"] <- as.character(example_data[,"patient_id"])
df_list <- split(example_data, example_data[,"patient_id"])
df_list <- lapply(df_list, function(y) y[,str_detect(colnames(y), "PC")])
df_list <- lapply(df_list, function(y) as.matrix(y[,1:10]))
mod_list <- .calc_dens(df_list, dens = "KNN", BPPARAM = BiocParallel::SerialParam())
all_combn <- combn(sample_name, 2)
patient_pair_list <- lapply(seq_len(ncol(all_combn)), function(i) all_combn[,i])
distance_list <- BiocParallel::bplapply(patient_pair_list, function(w){
                                        .calc_dist(mod_list = mod_list, df_list = df_list, k = 50,
                                        s1 = w[1], s2 = w[2], dens = "KNN", ndim = 10,
                                        r=10000, ep = 1e-64, dist_mat = "KL", varapp = FALSE,
                                        epapp = FALSE)},BPPARAM=BiocParallel::SerialParam())
data("example_data")
library(stringr)
sample_name <- as.character(unique(example_data[, "patient_id"]))
example_data[,"patient_id"] <- as.character(example_data[,"patient_id"])
df_list <- split(example_data, example_data[,"patient_id"])
df_list <- lapply(df_list, function(y) y[,str_detect(colnames(y), "PC")])
df_list <- lapply(df_list, function(y) as.matrix(y[,1:10]))
mod_list <- .calc_dens(df_list, dens = "KNN", BPPARAM = BiocParallel::SerialParam())
dist_test <- .calc_kl(mod_list, sample_name[1], sample_name[2], df_list, dens = "KNN",
                     r = 10000,k=50,varapp=FALSE,epapp=FALSE, ep = 1e-64)
data(example_data)
library(stringr)
sample_name <- as.character(unique(example_data[, "patient_id"]))
example_data[,"patient_id"] <- as.character(example_data[,"patient_id"])
df_list <- split(example_data, example_data[,"patient_id"])
df_list <- lapply(df_list, function(y) y[,str_detect(colnames(y), "PC")])
df_list <- lapply(df_list, function(y) as.matrix(y[,1:10]))
#working with large data set, use BiocParallel
mod_list <- .calc_dens(df_list, dens = "KNN", BPPARAM = BiocParallel::SerialParam())
dist_test <- .calc_JS(mod_list, sample_name[1], sample_name[2], df_list, dens = "KNN",
                     r = 10000,k=50,ep = 1e-64,ndim = 10)
}
