---
title: "scRNA-Seq Patient Analysis using GloScope"
author:
- name: Hao Wang
  affiliation:
  - &UCB University of California, Berkeley, California, USA
  email: hao_wang@berkeley.edu
- name: Elizabeth Purdom
  affiliation:
  - *UCB
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{GloScope}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Overview {#Intro}

This package will go through the steps needed to implement the `GloScope`. `GloScope` is a framework for creating a global profile of a scRNA-Seq sample in order to globally compare and analyze multiple samples of scRNA-Seq. This is done by estimating for each sample the global gene expression distribution and calculating how divergent pairs of samples are from each other. The output from the package is a $n\times n$ divergence matrix with the pairwise divergences among different samples. This divergence matrix can be the input to other statistical and machine learning tools. 

`GloScope` estimates the density from a low dimensional representation of the gene measurements, such as PCA or scVI. Users must provide `GloScope` with a dataframe containing each cell's low-dimensional embeddings, along with the meta data which identifies to which sample each cell belongs

The package provides the function `plotMDS` in the package which allows the user to visualize the divergence matrix via Multi-dimensional Scaling, but the divergence matrix can also be ported to other algorithms as well.  


A common workflow of using `GloScope` for :

1. Obtain the dimension reduction embedding of the cells and specify how many dimensions. This is done outside of the `GloScope` package

2. Choose a density estimation method (GMM/KNN) to estimate the distribution of each patients.

3. Calculate the KL divergence of each sample pair.

4. Visualize the distance matrix through MDS first two dimensions using the `plotMDS` function 


# Example implementation {# Examp}

In this section, we use a toy example to illustrate the input, output and visualization of `GloScope` pipeline. 


The data was a subset from the COVID PBMC data set, retrieved from [Stephenson et al (2021)](https://doi.org/10.1038/s41591-021-01329-2), using the following link: https://www.ebi.ac.uk/biostudies/arrayexpress/studies/E-MTAB-10026. There were a total of 647,366 blood mononuclear cells from 130 patients, categorized into COVID patients, healthy control donor, patients with other non-COVID respiratory disease and volunteers administered with intravenous lipopolysaccharide (IV-LPS). For computational timing consideration, we subset the data to contains the samples only from COVID and healthy control donor. We further down-sampled the data so each sample has 500 cells; this is not a recommended step for normal analysis, but done just to create a small manageable dataset for this tutorial.


## Data Input

We first load the `GloScope` package and bring in the example dataset.

```{r load-libs, message = FALSE,  warning = FALSE}
library(GloScope)
data("example_data")
```

```{r}
head(example_data[,1:10])
```
Each row of the matrix is a cell, and the data.frame has columns for meta data (`patient_id` and `Status`) as well as the PC embeddings for each cell.

We can see that each sample has 500 cells, as expected (because we downsampled to only 500 cells per patient).

```{r}
table(example_data$patient_id, example_data$Status)
```


`GloScope` expects that the user provides `GloScope` with a dataframe containing each cell's low-dimensional embeddings, along with the meta data which minimally identifies to which sample each cell belongs (though additional metadata can be provided).

The example dataset above consists of the PCA embeddings calculated from our small example COVID dataset. These were created by performing PCA on the gene expression matrix and obtained the first 50 PC embeddings. This would be typically done within other packages, such as `Seurat`.  A example of construct the input data frame from Seurat object would be (not evaluated here):

```{r eval = F}
cbind(seurat_object@meta.data, 
                 seurat_object@reductions$pca@cell.embeddings)
```


## Calculating divergence matrix

After the input data frame is ready, we use the function `gloscope` to approximate the divergence matrix. To do so, several arguments are required to be specified:

1. The column name that identifies the sample id of each cell in the input data (`sample_id`)

2. The variable name for dimension reduction embedding (e.g, `PC` for PC_1, PC_2, etc.,)

3. The density estimation method the user want to implement (`dens`); can be `KNN` or `GMM`. 

4. How many dimensions user want to use for dimension reductions.

5. If `KNN` is chosen in Step1, `k` needs to be selected. By default, `k = 50`.

Following is the illustration of using example data, with KNN density estimation, to calculate the KL divergence among samples.

```{r}
dist_test <- gloscope(embedding_matrix=example_data[,3:12], cell_sample_ids = example_data$patient_id,  dens = "KNN", dist_mat = "KL")

dist_test[1:5,1:5]
```

# Visualization of the divergence matrix

A classical way to visualize a divergence matrix is using a heatmap. 

```{r}
library(NMF)
aheatmap(dist_test)
```


The user could also choose to use the function `plotMDS` in this package to draw the MDS plots. `plotMDS` simply a wrapper to the `isoMDS` function from the package `MASS`, where `plotMDS` color-codes the samples based on other meta data. 

To run `plotMDS`, we also need to create a matrix with the relevant meta data at the sample level, rather than the cell level

```{r}
pat_info <- unique(example_data[, c("patient_id", "Status")])
head(pat_info)
```
We can then plot the MDS representation with each sample/patient color-coded by the `Status` variable. 

```{r}
mds_result = plotMDS(dist_mat = dist_test, n = 2,
                     x =  pat_info, sample_id="patient_id", group_id="Status")
```

`plotMDS` returns a list with the `plot` element containing the `ggplot2` object. We can visualize the plot by calling it:

```{r}
mds_result$plot
```


# Parallelization and Random Seeds

To speed-up calculations of the pair-wise divergences, `GloScope` allows for parallelizing the calculation. The argument `BPPARAM` controls the parameters of the parallelization (see `bplapply`). 

The default is no parallelization, but the iteration across sample-pairs will still via the function `bplapply`. In this case (i.e. no parallelization), the argument is simply `BPPARAM = BiocParallel::SerialParam()`. 

## Random seed 

The calculation of the KL divergence from the GMM density estimate uses Monte-Carlo approximation, and hence has to randomly sample from the estimated density. To set the seed for the pseudo-random number generator used in the simulation, the seed needs to be set within the argument to `BPPARAM` and **not** by a call to `set.seed` (see https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Random_Numbers.html for more information). 

This is how the seed must be set, *even if there is no parallelization* chosen (the default), because the iteration over sample pairs is sent through `bplapply` function regardless, as noted above. Setting the seed outside the function via `set.seed` will not have an effect on the function. 

The following is an example of how to set the random seed when running the `GMM` option, using the default of no parallelization:

```{r eval = TRUE}
dist_test_gmm <- gloscope(embedding_matrix=example_data[,3:12], cell_sample_ids = example_data$patient_id, dens = "GMM", dist_mat = "KL",

                     BPPARAM = BiocParallel::SerialParam(RNGseed = 1))
```

The same argument (`RNGseed`) can be added to other `BPPARAM` arguments to set the seed.

Note that the `KNN` estimation procedure does not have any Monte-Carlo approximation steps, and thus does not need to have a random seed.

# SessionInfo {-}

```{r sessionInfo}
sessionInfo()
```
