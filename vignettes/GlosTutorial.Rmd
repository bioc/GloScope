---
title: "scRNA-Seq Patient Analysis using GloScope"
author:
- name: Hao Wang
  affiliation:
  - &UCB University of California, Berkeley, California, USA
  email: hao_wang@berkeley.edu
- name: Elizabeth Purdom
  affiliation:
  - *UCB
date: "`r Sys.Date()`"
output: 
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Glos}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Overview {#Intro}

This package will go through the steps needed to implement the `GloScope`. `GloScope` is a framework for creating a global profile of a scRNA-Seq sample in order to globally compare and analyze multiple samples of scRNA-Seq. This is done by estimating for each sample the global gene expression distribution and calculating how divergent pairs of samples are from each other. The output from the package is a $n\times n$ divergence matrix with the pairwise divergences among different samples. This divergence matrix can be the input to other statistical and machine learning tools. 

`GloScope` estimates the density from a low dimensional representation of the gene measurements, such as PCA or scVI. Users must provide `GloScope` with a dataframe containing each cell's low-dimensional embeddings, along with the meta data which identifies to which sample each cell belongs

The package provides the function `plotMDS` in the package which allows the user to visualize the divergence matrix via Multi-dimensional Scaling, but the divergence matrix can also be ported to other algorithms as well.  


A common workflow of using `GloScope` for :

1. Obtain the dimension reduction embedding of the cells and specify how many dimensions. This is done outside of the `GloScope` package

2. Choose a density estimation method (GMM/KNN) to estimate the distribution of each patients.

3. Calculate the KL divergence of each sample pair.

4. Visualize the distance matrix through MDS first two dimensions using the `plotMDS` function 


# Example implementation {# Examp}

In this section, we use a toy example to illustrate the input, output and visualization of `GloScope` pipeline. 


The data was a subset from the COVID PBMC data set, retrieved from [Stephenson et al (2021)](https://doi.org/10.1038/s41591-021-01329-2), using the following link: https://www.ebi.ac.uk/biostudies/arrayexpress/studies/E-MTAB-10026. There were a total of 647,366 blood mononuclear cells from 130 patients, categorized into COVID patients, healthy control donor, patients with other non-COVID respiratory disease and volunteers administered with intravenous lipopolysaccharide (IV-LPS). For computational timing consideration, we subset the data to contains the samples only from COVID and healthy control donor. We further down-sampled the data so each sample has 500 cells.


## Data Input

We first load the `GloScope` package and bring in the example dataset.

```{r load-libs, message = FALSE,  warning = FALSE}
library(GloScope)
data("example_data")
```

```{r}
head(example_data[,1:10])
```
Each row of the matrix is a cell, and the data.frame has columns for meta data (`patient_id` and `Status`) as well as the PC embeddings for each cell.

We can see that each sample has 500 cells, as expected (because we downsampled to only 500 cells per patient).

```{r}
table(example_data$patient_id, example_data$Status)
```


`GloScope` expects that the user provides `GloScope` with a dataframe containing each cell's low-dimensional embeddings, along with the meta data which minimally identifies to which sample each cell belongs (though additional metadata can be provided).

The example dataset above consists of the PCA embeddings calculated from our small example COVID dataset. These were created by performing PCA on the gene expression matrix and obtained the first 50 PC embeddings. This would be typically done within other packages, such as `Seurat`.  A example of construct the input data frame from Seurat object would be (not evaluated here):

```{r eval = F}
cbind(seurat_object@meta.data, 
                 seurat_object@reductions$pca@cell.embeddings)
```


## Calculating divergence matrix

After the input data frame is ready, we use the function `distMat` to approximate the divergence matrix. To do so, several arguments are required to be specified:

1. The column name that identifies the sample id of each cell in the input data (`sample_id`)

2. The variable name for dimension reduction embedding (e.g, `PC` for PC_1, PC_2, etc.,)

3. The density estimation method the user want to implement (`dens`); can be `KNN` or `GMM`. 

4. How many dimensions user want to use for dimension reductions.

5. If `KNN` is chosen in Step1, `k` needs to be selected. By default, `k = 50`.

Following is the illustration of using example data, with KNN density estimation, to calculate the KL divergence among samples.

```{r}
dist_test <- distMat(example_data, sample_id = "patient_id", dim_redu = "PC",
                     ndim = 10, dens = "KNN", dist_mat = "KL")

dist_test[1:5,1:5]
```

### Random seed 

We implement biocparallel when we draw monte-carlo simulation for GMM estimation. Therefore, to ensure we get the same results everytime, we need to set the random seed for GMM. More detatiled could be found here: https://bioconductor.org/packages/release/bioc/vignettes/BiocParallel/inst/doc/Random_Numbers.html.


Following is an example:

```{r eval = F}
set.seed(1)
dist_test <- distMat(example_data, sample_id = "patient_id", dim_redu = "PC",
                     ndim = 10, dens = "GMM", r=10000, ep = 1e-64, dist_mat = "KL",
                     BPPARAM = BiocParallel::SerialParam(RNGseed = 1), varapp = FALSE,
                     returndens = FALSE, epapp = FALSE)
```


## visualization of distance matrix

A classical way to visualize the distance matrix is using the heatmap. 

```{r}
library(NMF)

aheatmap(dist_test)
```


The user could also choose to use the function `plotMDS` in this package to draw the MDS plots. In order to do so, we also need to obtain the sample level meta data. An example is presented below.

```{r}
pat_info <- unique(example_data[, c("patient_id", "Status")])

mds_result = plotMDS(dist_mat = dist_test, n = 2,
                     x =  pat_info, "patient_id", "Status")

mds_result$plot
```

# SessionInfo {-}

```{r sessionInfo}
sessionInfo()
```
